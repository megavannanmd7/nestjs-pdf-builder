/* eslint-disable */
import PDFDocument = require('pdfkit');
import type PDFKit from 'pdfkit';
import { PdfSections } from './pdf.sections';

/**
 * Converts bullet lists (â€¢ ...) into single-line rows for the table.
 * Handles wrapped lines in the input content as well.
 */
function extractBulletRows(text: string): string[] {
  const lines = text.split('\n');
  const rows: string[] = [];
  let current = '';

  for (const rawLine of lines) {
    const line = rawLine.trim();

    if (!line) continue;

    if (line.startsWith('â€¢')) {
      // New bullet starts â€” push the previous bullet if present
      if (current) rows.push(current.trim());

      current = line.replace(/^â€¢\s*/, '');
    } else {
      // Bullet continuation (wrapped lines)
      current += ' ' + line;
    }
  }

  if (current) rows.push(current.trim());

  return rows;
}

/**
 * Converts bullet lists with delimited values (e.g., â€¢ item | detail 1 | detail 2)
 * into a 2D array of strings for table rows.
 * @param text The raw string content.
 * @param columns The number of columns expected in the table.
 * @param delimiter The character separating values in the content.
 */
function extractTableRows(text: string, columns: number, delimiter = '|'): string[][] {
  const bulletRows = extractBulletRows(text);
  return bulletRows.map(row => {
    const values = row.split(delimiter).map(v => v.trim());
    // Ensure the row has the correct number of columns, padding with empty strings if needed.
    return Array.from({ length: columns }, (_, i) => values[i] ?? '');
  });
}

export interface PDFModel {
  title: string;
  chart?: Buffer | null;
  summary: string;
  quickActions?: string; // <--- New Field
  sections: Array<{ title: string; content: string }>;

  projectName?: string;
  projectOwner?: string;
  reportStartDate?: string;
  reportEndDate?: string;

  score?: number;
  health?: string;
}

export class PdfBuilder {
  static async buildPdfBuffer(model: PDFModel): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          autoFirstPage: false,
          size: 'A4',
          margin: 50
        });

        const buffers: Buffer[] = [];
        doc.on('data', (chunk) => buffers.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(buffers)));

        // -------------------------------------
        // PAGE START
        // -------------------------------------
        doc.addPage();

        // TITLE + SUBTITLE + METADATA
        PdfSections.renderTitle(doc, model.title);
        PdfSections.renderSubtitle(doc, 'Generated by Paxi AI');
        PdfSections.renderHeaderBlock(doc, model);

        // =========================================================
        // SECTION 1: PROJECT SUMMARY (Container)
        // =========================================================
        
        // A. Main Header
        PdfSections.renderSectionTitleOnly(doc, 'Project Summary');
        
        // B. Summary Text (AI Summary)
        // Render text without a header, just content
        doc.fontSize(10).text(model.summary, { align: 'justify' });
        doc.moveDown(1.5);

        // C. AI Score Trend (Chart)
        // We pass 'false' to a new param to say "don't move down too much"
        PdfSections.renderScoreAndChart(doc, model.health!, model.score!, model.chart ?? null);
        
        // D. Quick Actions
        if (model.quickActions && model.quickActions.trim().length > 0) {
           // Ensure you aren't at the bottom of the page
           if (doc.y > doc.page.height - 100) doc.addPage();

           PdfSections.renderSubHeader(doc, 'Quick Actions');
           doc.fontSize(10).text(model.quickActions, { align: 'left' });
           doc.moveDown(1.5);
        }

        // =========================================================
        // SECTION 2: TABLES (Accomplishments & Next Week)
        // =========================================================
        
        // Find data
        const accomplishments = model.sections.find(s => 
          (s.title || '').toLowerCase().includes('accomplishments')
        );
        const nextPlan = model.sections.find(s => 
          (s.title || '').toLowerCase().includes('next week')
        );

        // Parse rows
        const accRows = extractTableRows(accomplishments?.content ?? '', 4);
        const nextRows = extractTableRows(nextPlan?.content ?? '', 4);

        // Render Accomplishments
        if (accRows.length > 0) {
          const title = accomplishments?.title ?? 'Accomplishments';
          // Pass title to renderTable for look-ahead logic
          PdfSections.renderTable(
            doc,
            ['Task / Feature', 'Date', 'Impact', 'Owner'],
            accRows,
            title
          );
        }

        // Render Next Week Plan
        if (nextRows.length > 0) {
          const title = nextPlan?.title ?? 'Next Week Plan';
          // Pass title to renderTable for look-ahead logic
          PdfSections.renderTable(
            doc,
            ['Task / Deliverable', 'Due Date', 'Impact', 'Owner'],
            nextRows,
            title
          );
        }

        doc.end();
      } catch (err) {
        reject(err);
      }
    });
  }
}

// export class PdfBuilder {
//   static async buildPdfBuffer(model: PDFModel): Promise<Buffer> {
//     return new Promise((resolve, reject) => {
//       try {
//         const doc = new PDFDocument({
//           autoFirstPage: false,
//           size: 'A4',
//           margin: 50
//         });

//         const buffers: Buffer[] = [];

//         doc.on('data', (chunk) => buffers.push(chunk));
//         doc.on('end', () => resolve(Buffer.concat(buffers)));

//         // -------------------------------------
//         // PAGE START
//         // -------------------------------------
//         doc.addPage();

//         // TITLE + SUBTITLE
//         PdfSections.renderTitle(doc, model.title);
//         PdfSections.renderSubtitle(doc, 'Generated by Paxi AI');

//         // METADATA BLOCK
//         PdfSections.renderHeaderBlock(doc, model);

//         // SUMMARY
//         PdfSections.renderSection(doc, 'Project Summary', model.summary);

//         // AI SCORE TREND
//         PdfSections.renderSection(doc, 'AI Score Trend', '');
//         PdfSections.renderScoreAndChart(doc, model.health!, model.score!, model.chart ?? null);


//         // -------------------------------------
//         // NORMAL PARAGRAPH SECTIONS
//         // Skip Accomplishments + Next Week since those belong in tables.
//         // -------------------------------------
//         for (const sec of model.sections) {
//   // ðŸ” ROBUST CHECK: Convert to lowercase and check for keywords
//   const titleLower = (sec.title || '').toLowerCase();
  
//   const isTableSection =
//     titleLower.includes('accomplishments') ||
//     titleLower.includes('next week'); // Matches "Next Week Plan", "Next Week's Plan", etc.

//   // If it's NOT a table section, render it normally.
//   if (!isTableSection) {
//     PdfSections.renderSection(doc, sec.title, sec.content);
//   }
// }
// const accomplishments = model.sections.find(s => 
//   (s.title || '').toLowerCase().includes('accomplishments')
// );
// const nextPlan = model.sections.find(s => 
//   (s.title || '').toLowerCase().includes('next week')
// );

// // Parse delimited bullet content â†’ table rows
// const accRows = extractTableRows(accomplishments?.content ?? '', 4);
// const nextRows = extractTableRows(nextPlan?.content ?? '', 4);

// // Render Accomplishments Table
// if (accRows.length > 0) {
//   const title = accomplishments?.title ?? 'Accomplishments';
  
//   PdfSections.renderTable(
//     doc,
//     ['Task / Feature', 'Date', 'Impact', 'Owner'],
//     accRows,
//     title 
//   );
// }

// // Render Next Week Plan Table
// if (nextRows.length > 0) {
//   const title = nextPlan?.title ?? 'Next Week Plan';

//   PdfSections.renderTable(
//     doc,
//     ['Task / Deliverable', 'Due Date', 'Impact', 'Owner'],
//     nextRows,
//     title
//   );
// }

//         doc.end();
//       } catch (err) {
//         reject(err);
//       }
//     });
//   }
// }
